<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>结构体标签</title>
    <link href="/2023/07/16/%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE/"/>
    <url>/2023/07/16/%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="结构体标签"><a href="#结构体标签" class="headerlink" title="结构体标签"></a>结构体标签</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-comment">// 结构体标签 为了向别人提供字段的说明</span><br><span class="hljs-keyword">type</span> resume <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot; doc:&quot;我的名字&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findDoc</span><span class="hljs-params">(stru <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span> &#123;<br>    t := reflect.TypeOf(stru).Elem()<br>    doc := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>        doc[t.Field(i).Tag.Get(<span class="hljs-string">&quot;json&quot;</span>)] = t.Field(i).Tag.Get(<span class="hljs-string">&quot;doc&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> doc<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> stru resume<br>    doc := findDoc(&amp;stru)<br>    fmt.Printf(<span class="hljs-string">&quot;name字段为：%s\n&quot;</span>, doc[<span class="hljs-string">&quot;name&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>json示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Movie <span class="hljs-keyword">struct</span> &#123;<br>Title  <span class="hljs-type">string</span>   <span class="hljs-string">`json:&quot;title&quot;`</span><br>Year   <span class="hljs-type">int</span>      <span class="hljs-string">`json:&quot;year&quot;`</span><br>Price  <span class="hljs-type">int</span>      <span class="hljs-string">`json:&quot;rmb&quot;`</span><br>Actors []<span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;actors&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>movie := Movie&#123;<span class="hljs-string">&quot;喜剧之王&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">10</span>, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;zhouxingchi&quot;</span>, <span class="hljs-string">&quot;zhangbozhi&quot;</span>&#125;&#125;<br><span class="hljs-comment">//编码的过程 结构体--&gt; json</span><br>jsonStr, err := json.Marshal(movie)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;json marshal error&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;jsonStr = %s\n&quot;</span>, jsonStr)<br><br><span class="hljs-comment">//解码的过程 jsonStr --&gt; 结构体</span><br><span class="hljs-comment">//jsonStr = &#123;&quot;title&quot;:&quot;喜剧之王&quot;,&quot;year&quot;:2000,&quot;rmb&quot;:10,&quot;actors&quot;:[&quot;zhouxingchi&quot;,&quot;zhangbozhi&quot;]&#125;</span><br>myMovie := Movie&#123;&#125;<br>err = json.Unmarshal(jsonStr, &amp;myMovie)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;json unmarshal error&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;myMovie=%v\n&quot;</span>, myMovie)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
      <tag>结构体标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射reflect</title>
    <link href="/2023/07/16/%E5%8F%8D%E5%B0%84reflect/"/>
    <url>/2023/07/16/%E5%8F%8D%E5%B0%84reflect/</url>
    
    <content type="html"><![CDATA[<h1 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h1><h2 id="编程中反射的概念"><a href="#编程中反射的概念" class="headerlink" title="编程中反射的概念"></a>编程中反射的概念</h2><p>反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。<br>Golang语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。</p><h2 id="interface和反射"><a href="#interface和反射" class="headerlink" title="interface和反射"></a>interface和反射</h2><p>● 变量包括（type, value）两部分<br>● type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型<br>● 类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.</p><p>反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。</p><p>在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">(value, <span class="hljs-keyword">type</span>)<br></code></pre></td></tr></table></figure><p>value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。</p><h2 id="Golang的反射relect"><a href="#Golang的反射relect" class="headerlink" title="Golang的反射relect"></a>Golang的反射relect</h2><h3 id="ValueOf和TypeOf"><a href="#ValueOf和TypeOf" class="headerlink" title="ValueOf和TypeOf"></a>ValueOf和TypeOf</h3><p>Golang的reflect反射包提供了两种类型（两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf()和reflect.TypeOf()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br><br>    fmt.Println(<span class="hljs-string">&quot;type: &quot;</span>, reflect.TypeOf(num))<br>    fmt.Println(<span class="hljs-string">&quot;value: &quot;</span>, reflect.ValueOf(num))<br>&#125;<br><br>运行结果:<br><span class="hljs-keyword">type</span>:  <span class="hljs-type">float64</span><br>value:  <span class="hljs-number">1.2345</span><br></code></pre></td></tr></table></figure><h3 id="从relfect-Value中获取接口interface的信息"><a href="#从relfect-Value中获取接口interface的信息" class="headerlink" title="从relfect.Value中获取接口interface的信息"></a>从relfect.Value中获取接口interface的信息</h3><p>当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。原有类型可能已知可能未知。</p><p>####已知原有类型【进行“强制转换”】<br>已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">realValue := value.Interface().(已知的类型)<br><span class="hljs-number">1.</span>  转换的时候，如果转换的类型不完全符合，则直接<span class="hljs-built_in">panic</span>，类型要求非常严格！ <br><span class="hljs-number">2.</span>  转换的时候，要区分是指针还是值<br><span class="hljs-number">3.</span>  也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量” <br></code></pre></td></tr></table></figure><h4 id="未知原有类型【遍历探测其Filed】"><a href="#未知原有类型【遍历探测其Filed】" class="headerlink" title="未知原有类型【遍历探测其Filed】"></a>未知原有类型【遍历探测其Filed】</h4><p>很多情况下，我们可能并不知道其具体类型，需要我们进行遍历探测其Filed来得知，示例如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    Id   <span class="hljs-type">int</span><br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span></span> ReflectCallFunc() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Allen.Wu ReflectCallFunc&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    user := User&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Allen.Wu&quot;</span>, <span class="hljs-number">25</span>&#125;<br><br>    DoFiledAndMethod(user)<br><br>&#125;<br><br><span class="hljs-comment">// 通过接口来获取任意参数，然后一一揭晓</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoFiledAndMethod</span><span class="hljs-params">(input <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><br>    getType := reflect.TypeOf(input)<br>    fmt.Println(<span class="hljs-string">&quot;get Type is :&quot;</span>, getType.Name())<br><br>    getValue := reflect.ValueOf(input)<br>    fmt.Println(<span class="hljs-string">&quot;get all Fields is:&quot;</span>, getValue)<br><br>    <span class="hljs-comment">// 获取方法字段</span><br>    <span class="hljs-comment">// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span><br>    <span class="hljs-comment">// 2. 再通过reflect.Type的Field获取其Field</span><br>    <span class="hljs-comment">// 3. 最后通过Field的Interface()得到对应的value</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; getType.NumField(); i++ &#123;<br>        field := getType.Field(i)<br>        value := getValue.Field(i).Interface()<br>        fmt.Printf(<span class="hljs-string">&quot;%s: %v = %v\n&quot;</span>, field.Name, field.Type, value)<br>    &#125;<br><br>    <span class="hljs-comment">// 获取方法</span><br>    <span class="hljs-comment">// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; getType.NumMethod(); i++ &#123;<br>        m := getType.Method(i)<br>        fmt.Printf(<span class="hljs-string">&quot;%s: %v\n&quot;</span>, m.Name, m.Type)<br>    &#125;<br>&#125;<br><br>运行结果：<br>get Type is : User<br>get all Fields is: &#123;<span class="hljs-number">1</span> Allen.Wu <span class="hljs-number">25</span>&#125;<br>Id: <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br>Name: <span class="hljs-type">string</span> = Allen.Wu<br>Age: <span class="hljs-type">int</span> = <span class="hljs-number">25</span><br>ReflectCallFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(main.User)</span></span><br></code></pre></td></tr></table></figure><p>通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumField进行遍历</li><li>再通过reflect.Type的Field获取其Field</li><li>最后通过Field的Interface()得到对应的value</li></ol><p>通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：</p><ol><li>先获取interface的reflect.Type，然后通过NumMethod进行遍历</li><li>再分别通过reflect.Type的Method获取对应的真实的方法（函数）</li><li>最后对结果取其Name和Type得知具体的方法名</li><li>也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><h3 id="通过reflect-Value设置实际变量的值"><a href="#通过reflect-Value设置实际变量的值" class="headerlink" title="通过reflect.Value设置实际变量的值"></a>通过reflect.Value设置实际变量的值</h3><p>reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">1.2345</span><br>    fmt.Println(<span class="hljs-string">&quot;old value of pointer:&quot;</span>, num)<br><br>    <span class="hljs-comment">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span><br>    pointer := reflect.ValueOf(&amp;num)<br>    newValue := pointer.Elem()<br><br>    fmt.Println(<span class="hljs-string">&quot;type of pointer:&quot;</span>, newValue.Type())<br>    fmt.Println(<span class="hljs-string">&quot;settability of pointer:&quot;</span>, newValue.CanSet())<br><br>    <span class="hljs-comment">// 重新赋值</span><br>    newValue.SetFloat(<span class="hljs-number">77</span>)<br>    fmt.Println(<span class="hljs-string">&quot;new value of pointer:&quot;</span>, num)<br><br>    <span class="hljs-comment">////////////////////</span><br>    <span class="hljs-comment">// 如果reflect.ValueOf的参数不是指针，会如何？</span><br>    pointer = reflect.ValueOf(num)<br>    <span class="hljs-comment">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span><br>&#125;<br><br>运行结果：<br>old value of pointer: <span class="hljs-number">1.2345</span><br><span class="hljs-keyword">type</span> of pointer: <span class="hljs-type">float64</span><br>settability of pointer: <span class="hljs-literal">true</span><br><span class="hljs-built_in">new</span> value of pointer: <span class="hljs-number">77</span><br></code></pre></td></tr></table></figure><ol><li>需要传入的参数是* float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，注意一定要是指针。</li><li>如果传入的参数不是指针，而是变量，那么<br>  ○ 通过Elem获取原始值对应的对象则直接panic<br>  ○ 通过CanSet方法查询是否可以设置返回false</li><li>newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</li><li>reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的</li><li>也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】</li><li>struct 或者 struct 的嵌套都是一样的判断处理方式</li></ol><h3 id="通过reflect-ValueOf来进行方法的调用"><a href="#通过reflect-ValueOf来进行方法的调用" class="headerlink" title="通过reflect.ValueOf来进行方法的调用"></a>通过reflect.ValueOf来进行方法的调用</h3><p>未完待续</p><p>Golang的反射很慢</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
      <tag>reflect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interface与类型断言</title>
    <link href="/2023/07/16/interface%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/"/>
    <url>/2023/07/16/interface%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="interface与类型断言"><a href="#interface与类型断言" class="headerlink" title="interface与类型断言"></a>interface与类型断言</h1><p>Golang的语言中提供了断言的功能。golang中的所有程序都实现了interface{}的接口，这意味着，所有的类型如string,int,int64甚至是自定义的struct类型都就此拥有了interface{}的接口，这种做法和java中的Object类型比较类似。那么在一个数据通过func funcName(interface{})的方式传进来的时候，也就意味着这个参数被自动的转为interface{}的类型。</p><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>直接断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125;<br>fmt.Println(<span class="hljs-string">&quot;Where are you,Jonny?&quot;</span>, a.(<span class="hljs-type">string</span>))<br></code></pre></td></tr></table></figure><p>断言失败可能会导致panic，断言前一般先判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">value, ok := a.(<span class="hljs-type">string</span>) <span class="hljs-comment">// 失败时ok的值为false；成功ok的值时true，同时value返回正确的值</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
      <tag>interface</tag>
      
      <tag>类型断言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象特征</title>
    <link href="/2023/07/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81/"/>
    <url>/2023/07/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>给结构体定义方法时如果接受者是指针类型的，函数中的操作会影响到结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><br><span class="hljs-comment">//定义一个结构体</span><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-type">string</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> method1() &#123;<br>    t.name = <span class="hljs-string">&quot;new name1&quot;</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> method2() &#123;<br>    t.name = <span class="hljs-string">&quot;new name2&quot;</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><br>    t := T&#123;<span class="hljs-string">&quot;old name&quot;</span>&#125;<br><br><br>    fmt.Println(<span class="hljs-string">&quot;method1 调用前 &quot;</span>, t.name)<br>    t.method1()<br>    fmt.Println(<span class="hljs-string">&quot;method1 调用后 &quot;</span>, t.name)<br><br><br>    fmt.Println(<span class="hljs-string">&quot;method2 调用前 &quot;</span>, t.name)<br>    t.method2()<br>    fmt.Println(<span class="hljs-string">&quot;method2 调用后 &quot;</span>, t.name)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">method1 调用前  old name<br>method1 调用后  old name<br>method2 调用前  old name<br>method2 调用后  new name2<br></code></pre></td></tr></table></figure><h2 id="方法值"><a href="#方法值" class="headerlink" title="方法值"></a>方法值</h2><p>将一个结构体的方法分两步执行，第一步先将方法赋值给一个变量，成为方法值。之后调用时不需要再指定接收器，只需要传入参数即可。<br>如p.Distance()，将p.Distance传给一个变量distanceFormP，然后调用distanceFormP(otherPoint)</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
      <tag>面向对象特征</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>slice和map</title>
    <link href="/2023/07/15/slice%E5%92%8Cmap/"/>
    <url>/2023/07/15/slice%E5%92%8Cmap/</url>
    
    <content type="html"><![CDATA[<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><p>Go切片是对数组的抽象</p><p>Go使用<code>var myArr1 [10]int</code>声明的数组是固定数组，长度不可改变，不适用于某些场景。Go提供了内置类型切片（“动态数组”），切片的长度不固定，追加元素超过切片容量后切片的容量会增大。</p><h2 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h2><p>声明一个未制定大小的数组就是一个切片，但是没有分配空间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier []<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>使用make()函数在声明的时候分配空间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> slice1 []<span class="hljs-keyword">type</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">type</span>, <span class="hljs-built_in">len</span>)<br><br>也可以简写为<br><br>slice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">type</span>, <span class="hljs-built_in">len</span>)<br></code></pre></td></tr></table></figure><p>可选参数capacity制定切片容量<code>make([]T, length, capacity)</code>不指定capacity时len&#x3D;cap  <br>len是数组的长度，也是切片的初始长度。</p><h2 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h2><p>直接初始化，值为1，2，3，len&#x3D;cap&#x3D;3</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := []<span class="hljs-type">int</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>根据其他数组或切片来初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// startIndex/endIndex可选</span><br>s1 := s[startIndex:endIndex] <br></code></pre></td></tr></table></figure><h2 id="len-和cap-函数"><a href="#len-和cap-函数" class="headerlink" title="len()和cap()函数"></a>len()和cap()函数</h2><p>可以使用len()测量切片目前的长度，使用cap()测量切片目前的最大容量。</p><h2 id="空切片"><a href="#空切片" class="headerlink" title="空切片"></a>空切片</h2><p>未初始化的切片默认等于nil，长度和容量为0</p><h2 id="append-函数-和-copy-函数"><a href="#append-函数-和-copy-函数" class="headerlink" title="append()函数 和 copy() 函数"></a>append()函数 和 copy() 函数</h2><p>append()向切片（包括空切片）中追加元素，copy()复制原来的切片到新切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> numbers []<span class="hljs-type">int</span><br>   printSlice(numbers)<br><br><br>   <span class="hljs-comment">/* 允许追加空切片 */</span><br>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">0</span>)<br>   printSlice(numbers)<br><br><br>   <span class="hljs-comment">/* 向切片添加一个元素 */</span><br>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">1</span>)<br>   printSlice(numbers)<br><br><br>   <span class="hljs-comment">/* 同时添加多个元素 */</span><br>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>   printSlice(numbers)<br><br><br>   <span class="hljs-comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span><br>   numbers1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(numbers), (<span class="hljs-built_in">cap</span>(numbers))*<span class="hljs-number">2</span>)<br><br><br>   <span class="hljs-comment">/* 拷贝 numbers 的内容到 numbers1 */</span><br>   <span class="hljs-built_in">copy</span>(numbers1,numbers)<br>   printSlice(numbers1)   <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(x []<span class="hljs-type">int</span>)</span></span>&#123;<br>   fmt.Printf(<span class="hljs-string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="hljs-built_in">len</span>(x),<span class="hljs-built_in">cap</span>(x),x)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">len=0 cap=0 slice=[]<br>len=1 cap=1 slice=[0]<br>len=2 cap=2 slice=[0 1]<br>len=5 cap=6 slice=[0 1 2 3 4]<br>len=5 cap=12 slice=[0 1 2 3 4]<br></code></pre></td></tr></table></figure><p>思考：为什么同时添加2，3，4后，len从2增加到了5，cap增加到了6？</p><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map和slice类似，只不过数据结构不同</p><h2 id="声明map"><a href="#声明map" class="headerlink" title="声明map"></a>声明map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//第一种</span><br><span class="hljs-keyword">var</span> test1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br><span class="hljs-comment">// 使用map前需要先make分配数据空间</span><br>test1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">10</span>)<br>test1[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-string">&quot;php&quot;</span><br>test1[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-string">&quot;golang&quot;</span><br><br><span class="hljs-comment">// 第二种</span><br>test2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>test1[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-string">&quot;php&quot;</span><br>test1[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-string">&quot;golang&quot;</span><br><br><span class="hljs-comment">// 第三种</span><br>test3 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-string">&quot;php&quot;</span>,<br>    <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-string">&quot;golang&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
      <tag>slice</tag>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>defer</title>
    <link href="/2023/07/15/defer/"/>
    <url>/2023/07/15/defer/</url>
    
    <content type="html"><![CDATA[<h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><p>defer语句在函数运行结束之后才运行，被defer语句调用的函数称为延迟函数<br>defer压栈运行，多个defer以后进先出的顺序执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;2&quot;</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;3&quot;</span>)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;4&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>Demo()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">4<br>3<br>2<br>1<br></code></pre></td></tr></table></figure><p>defer作用：</p><p>● 释放占用的资源<br>● 捕捉处理异常<br>● 输出日志</p><h2 id="recover错误拦截"><a href="#recover错误拦截" class="headerlink" title="recover错误拦截"></a>recover错误拦截</h2><p>运行时panic异常一旦被引发会导致程序崩溃。<br>Go使用recover拦截panic的内建函数recover，可以让程序从panic的状态恢复并重新取得流程控制权。</p><p>recover只在defer调用的函数中有效</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Demo</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-comment">//定义10个元素的数组</span><br><span class="hljs-keyword">var</span> arr [<span class="hljs-number">10</span>]<span class="hljs-type">int</span><br><span class="hljs-comment">//错误拦截要在产生错误前设置</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//设置recover拦截错误信息</span><br>err := <span class="hljs-built_in">recover</span>()<br><span class="hljs-comment">//产生panic异常  打印错误信息</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;()<br><span class="hljs-comment">//根据函数参数为数组元素赋值</span><br><span class="hljs-comment">//如果i的值超过数组下标 会报错误：数组下标越界</span><br>arr[i] = <span class="hljs-number">10</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>Demo(<span class="hljs-number">10</span>)<br><span class="hljs-comment">//产生错误后 程序继续</span><br>fmt.Println(<span class="hljs-string">&quot;程序继续执行...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
      <tag>defer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/2023/07/15/%E5%87%BD%E6%95%B0/"/>
    <url>/2023/07/15/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>Go函数可以返回多个值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>   <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a, b := swap(<span class="hljs-string">&quot;Mahesh&quot;</span>, <span class="hljs-string">&quot;Kumar&quot;</span>)<br>   fmt.Println(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="init函数与import"><a href="#init函数与import" class="headerlink" title="init函数与import"></a>init函数与import</h2><p>init函数可以在任何package中，可以在一个package中出现零次或多次（为了可读性和维护，最好只写一个init）</p><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>main 只能在package main中，package main中必须有main函数</p><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>Go程序自动调用init()和main()，不需要手动调用。程序始于main包，如果在main中调用了其他包，那么在编译的时候依次导入。一个包被多个包导入，那么它将只导入一次。<br>一个包被导入后，先导入它导入的其他包，把这些包里的常量和变量进行初始化，然后执行init函数（如果有）。所有导入的包加载完毕后开始对main中的常量变量进行初始化，然后执行init函数（如果有），最后执行main函数。</p><img src="/2023/07/15/%E5%87%BD%E6%95%B0/image.png" class="" title="执行过程"><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>Go函数传递参数分为值传递和引用传递（指针传递）</p><p>值传递在调用函数时复制一份实际参数传递到函数中，不会影响到实际参数</p><p>引用传递使用取地址符&amp;将实际参数的地址传递给函数，函数的参数类型前加*号表示参数是指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">100</span><br>   <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span>= <span class="hljs-number">200</span><br><br><br>   fmt.Printf(<span class="hljs-string">&quot;交换前，a 的值 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换前，b 的值 : %d\n&quot;</span>, b )<br><br><br>   <span class="hljs-comment">/* 调用 swap() 函数</span><br><span class="hljs-comment">   * &amp;a 指向 a 指针，a 变量的地址</span><br><span class="hljs-comment">   * &amp;b 指向 b 指针，b 变量的地址</span><br><span class="hljs-comment">   */</span><br>   swap(&amp;a, &amp;b)<br><br><br>   fmt.Printf(<span class="hljs-string">&quot;交换后，a 的值 : %d\n&quot;</span>, a )<br>   fmt.Printf(<span class="hljs-string">&quot;交换后，b 的值 : %d\n&quot;</span>, b )<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x *<span class="hljs-type">int</span>, y *<span class="hljs-type">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br>   temp = *x    <span class="hljs-comment">/* 保存 x 地址上的值 */</span><br>   *x = *y      <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   *y = temp    <span class="hljs-comment">/* 将 temp 值赋给 y */</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量与常量</title>
    <link href="/2023/07/13/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/"/>
    <url>/2023/07/13/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><h3 id="单变量声明"><a href="#单变量声明" class="headerlink" title="单变量声明"></a>单变量声明</h3><p>声明变量使用var关键字</p><ol><li>指定变量类型不赋值<br><code>var v_name v_type</code></li><li>根据值自行判断变量类型<br><code>var v_name = value</code></li><li>省略var, 使用 :&#x3D;<br><code>v_name := value</code></li></ol><h3 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 1</span><br><span class="hljs-keyword">var</span> x,y <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> ( <span class="hljs-comment">// 这种写法一般用于全局变量</span><br>    a <span class="hljs-type">int</span><br>    b <span class="hljs-type">bool</span><br>)<br><span class="hljs-keyword">var</span> c,d <span class="hljs-type">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-keyword">var</span> e, f = <span class="hljs-number">123</span>, <span class="hljs-string">&quot;str&quot;</span><br></code></pre></td></tr></table></figure><p>不带声明格式的只能在函数体内声明<br><code>g, h := 123, &quot;在函数体内使用&quot;</code></p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>. 常量不会被修改<br>. 是一个简单值的标识符，数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> identifier [<span class="hljs-keyword">type</span>] = value<br></code></pre></td></tr></table></figure><p>如果省略类型[type]，编译器将根据变量的值自动判断类型（隐式类型定义）</p><p>常量可以用作枚举</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Unknown = <span class="hljs-number">0</span><br>    Female = <span class="hljs-number">1</span><br>    Male = <span class="hljs-number">2</span><br>)<br></code></pre></td></tr></table></figure><p>常量可以用len(), cap(), unsafe.Sizeof()常量计算表达式的值。常量表达式中的函数必须是内置函数。</p><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p>如果定义的常量只是为了彼此区分，它的值不那么重要，比如不同常量的值定义成0, 1, 2 …，可以使用iota自增长简化常量增长数字的定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Red = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>    Blue       <span class="hljs-comment">// 1</span><br>    Yellow     <span class="hljs-comment">// 2</span><br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
      <tag>变量</tag>
      
      <tag>常量</tag>
      
      <tag>iota</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
